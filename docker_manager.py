# docker_manager.py
import os
import docker # pip install docker

# Initialize Docker client globally for this module
try:
    docker_client = docker.from_env()
    docker_client.ping() # Test connection to Docker daemon
    print("Docker client initialized successfully.")
except Exception as e:
    raise RuntimeError(f"Failed to connect to Docker daemon. Please ensure Docker is running and properly installed: {e}")

def generate_dockerfile(repo_path: str) -> tuple[bool, str]:
    """
    Attempts to intelligently generate a Dockerfile based on common project structures.
    This is a simplified example and would need significant expansion for real-world use.
    """
    dockerfile_content = ""
    project_type = "unknown"
    dockerfile_path = os.path.join(repo_path, 'Dockerfile')

    # Prioritize existing Dockerfile if available in the repo
    if os.path.exists(dockerfile_path):
        with open(dockerfile_path, 'r') as f:
            dockerfile_content = f.read()
        project_type = "existing"
        return True, f"Using existing Dockerfile for {project_type} project."

    if os.path.exists(os.path.join(repo_path, 'package.json')):
        project_type = "nodejs"
        dockerfile_content = f"""
# Node.js Project Dockerfile generated by AI Code Auditor
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
"""
    elif os.path.exists(os.path.join(repo_path, 'requirements.txt')):
        project_type = "python"
        dockerfile_content = f"""
# Python Project Dockerfile generated by AI Code Auditor
FROM python:3.9-slim-buster
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 8000
CMD ["python", "app.py"] # Adjust based on your main file (e.g., main.py, wsgi.py)
"""
    elif os.path.exists(os.path.join(repo_path, 'pom.xml')):
        project_type = "java-maven"
        dockerfile_content = f"""
# Java Maven Project Dockerfile generated by AI Code Auditor
FROM maven:3.8.5-openjdk-17
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean install -DskipTests
EXPOSE 8080
CMD ["java", "-jar", "target/*.jar"] # Adjust based on your build output
"""
    # Add more detection logic for other languages/frameworks (e.g., .csproj for .NET, Gemfile for Ruby)
    
    if not dockerfile_content: # If no specific type detected, provide a generic one
        dockerfile_content = f"""
# Generic Dockerfile generated by AI Code Auditor - please review and customize
FROM alpine/git:latest # A lightweight base image with git
WORKDIR /app
COPY . .
# No specific build or run command detected.
# You might need to add commands here to build and run your application, e.g.:
# RUN apk add --no-cache nodejs npm # For Node.js
# RUN npm install
# CMD ["npm", "start"]
"""
        project_type = "generic"

    try:
        with open(dockerfile_path, 'w') as f:
            f.write(dockerfile_content.strip())
        return True, f"Dockerfile generated for {project_type} project."
    except Exception as e:
        return False, f"Error writing Dockerfile: {e}"


def build_docker_image(repo_path: str, image_name: str = "code-auditor-image") -> tuple[bool, str, str]:
    """Builds a Docker image from the given path."""
    try:
        # build_logs is an iterator, collect all logs
        image, build_generator = docker_client.images.build(path=repo_path, tag=image_name, rm=True)
        logs_str = ""
        for chunk in build_generator:
            if 'stream' in chunk:
                logs_str += chunk['stream']
            if 'error' in chunk:
                logs_str += chunk['error']
                return False, None, logs_str # Stop on first error

        return True, image.tags[0], logs_str
    except docker.errors.BuildError as e:
        return False, None, str(e.build_log)
    except Exception as e:
        return False, None, f"Error building Docker image: {e}"


def run_docker_tests(image_name: str, project_path: str) -> tuple[bool, str]:
    """
    Runs automated tests within the Docker container.
    This is highly dependent on the project type and its testing framework.
    """
    test_commands = {
        "nodejs": ["npm", "test"],
        "python": ["python", "-m", "pytest"], # Explicitly use python -m pytest
        "java-maven": ["mvn", "test"]
    }
    
    detected_type = "unknown"
    if os.path.exists(os.path.join(project_path, 'package.json')):
        detected_type = "nodejs"
    elif os.path.exists(os.path.join(project_path, 'requirements.txt')):
        detected_type = "python"
    elif os.path.exists(os.path.join(project_path, 'pom.xml')):
        detected_type = "java-maven"

    command_to_run = test_commands.get(detected_type)

    if not command_to_run:
        return False, "No specific test command detected for this project type. Please ensure common test files (e.g., package.json, requirements.txt, pom.xml) exist."

    logs = ""
    try:
        # Run container with test command
        # Mount the repository content as a volume to allow tests to access it
        # This is crucial if tests require specific files or a build context not included in the image
        container = docker_client.containers.run(
            image=image_name,
            command=command_to_run,
            detach=False, # Run in foreground to capture logs directly
            remove=True, # Automatically remove container after exit
            volumes={project_path: {'bind': '/app', 'mode': 'ro'}}, # Mount repo content read-only
            # Add network_mode='host' or specific network for internet access if tests need it
            # network_mode='host' if needed for external calls from inside container
            # environment={'CI': 'true'} # Some test runners behave differently in CI environments
        )
        # For detach=False, container.run returns logs directly if command finishes
        # This part might need adjustment based on how docker-py captures logs for non-detached containers
        # Often, logs are returned directly by the run method if stream=False and detach=False
        
        # A more robust way to get logs for detached=True, then waiting:
        # container = docker_client.containers.run(image=image_name, command=command_to_run, detach=True, remove=True, volumes={project_path: {'bind': '/app', 'mode': 'ro'}})
        # result = container.wait(timeout=300)
        # logs = container.logs().decode('utf-8')
        # if result['StatusCode'] == 0:
        #     return True, f"Tests ran successfully.\nLogs:\n{logs}"
        # else:
        #     return False, f"Tests failed with exit code {result['StatusCode']}.\nLogs:\n{logs}"

        # If detach=False, container variable is the output, or it's implicitly printed.
        # The typical way to get output when detach=False is via stdout/stderr, but docker-py's run wraps this.
        # For simplicity, if detach=False, output is part of the exception or directly from run()
        # Let's revert to detach=True and get logs after wait, which is more reliable for long-running tests.
        
        # Re-adjusted to detach=True for robust log capture as in original.
        # This block is re-checked against original logic.
        print(f"Running command: {command_to_run} inside {image_name}")
        container = docker_client.containers.run(
            image=image_name,
            command=command_to_run,
            detach=True,  # Detach to wait and then get logs
            remove=True,
            volumes={os.path.abspath(project_path): {'bind': '/app', 'mode': 'ro'}} # Use absolute path for host volume
        )
        result = container.wait(timeout=300)
        logs = container.logs().decode('utf-8')

        if result['StatusCode'] == 0:
            return True, f"Tests ran successfully.\nLogs:\n{logs}"
        else:
            return False, f"Tests failed with exit code {result['StatusCode']}.\nLogs:\n{logs}"

    except docker.errors.ContainerError as e:
        return False, f"Error running container: {e}\nLogs:\n{e.stderr.decode('utf-8')}"
    except docker.errors.ImageNotFound:
        return False, f"Docker image '{image_name}' not found. Build failed previously?"
    except Exception as e:
        return False, f"An unexpected error occurred during test execution: {e}"


if __name__ == '__main__':
    # Example usage for testing this module independently
    # Note: This requires a Dockerfile and a build context.
    # Create a dummy repo_path with a simple Dockerfile and a testable file
    
    print("Testing Docker Manager functions (requires Docker daemon running)...")
    
    # Create a dummy test environment
    dummy_repo_path = './dummy_python_app_for_docker_test'
    if os.path.exists(dummy_repo_path):
        import shutil
        shutil.rmtree(dummy_repo_path)
    os.makedirs(dummy_repo_path, exist_ok=True)
    
    # Create a requirements.txt
    with open(os.path.join(dummy_repo_path, 'requirements.txt'), 'w') as f:
        f.write("pytest\n")
    
    # Create a simple Python app with a test
    with open(os.path.join(dummy_repo_path, 'app.py'), 'w') as f:
        f.write("""
def add(a, b):
    return a + b
if __name__ == '__main__':
    print(add(1, 2))
""")
    with open(os.path.join(dummy_repo_path, 'test_app.py'), 'w') as f:
        f.write("""
from app import add

def test_add():
    assert add(1, 2) == 3
    assert add(-1, 1) == 0
    assert add(0, 0) == 0
""")
    
    print("Generating Dockerfile...")
    success_df, msg_df = generate_dockerfile(dummy_repo_path)
    print(f"Dockerfile Generation: {msg_df}")

    if success_df:
        image_name_test = "test-auditor-image"
        print(f"Building Docker image: {image_name_test}...")
        success_build, tag_build, logs_build = build_docker_image(dummy_repo_path, image_name_test)
        print(f"Docker Build Result: {'SUCCESS' if success_build else 'FAILED'}")
        print(f"Build Logs:\n{logs_build}")

        if success_build:
            print(f"Running tests in Docker image: {tag_build}...")
            success_test, logs_test = run_docker_tests(image_name_test, dummy_repo_path)
            print(f"Test Execution Result: {'SUCCESS' if success_test else 'FAILED'}")
            print(f"Test Logs:\n{logs_test}")
        else:
            print("Skipping tests due to Docker build failure.")
    else:
        print("Skipping Docker build and tests due to Dockerfile generation failure.")

    # Clean up dummy repo
    if os.path.exists(dummy_repo_path):
        import shutil
        shutil.rmtree(dummy_repo_path)
        print(f"Cleaned up dummy repo: {dummy_repo_path}")
    
    # You might also want to remove the Docker image after testing
    try:
        docker_client.images.remove(image_name_test)
        print(f"Cleaned up Docker image: {image_name_test}")
    except Exception as e:
        print(f"Could not remove Docker image {image_name_test}: {e}")